# 데이터베이스 아키텍처 비교: 분리 vs 통합

## 🎯 개요
식당관리 프로그램의 멀티테넌시 구현에서 데이터베이스 아키텍처 선택은 매우 중요한 결정사항입니다.

---

## 📊 비교 표

| 항목 | 데이터베이스 분리 | 데이터베이스 통합 |
|------|-------------------|-------------------|
| **구조** | 각 식당별 별도 DB | 단일 DB + restaurant_id |
| **데이터 격리** | 완전 격리 | RLS 정책으로 격리 |
| **확장성** | 매우 높음 | 보통 |
| **관리 복잡성** | 높음 | 낮음 |
| **비용** | 높음 | 낮음 |
| **성능** | 최적화 용이 | 최적화 복잡 |
| **백업** | 개별 백업 | 통합 백업 |
| **마이그레이션** | 복잡 | 단순 |

---

## 🏗️ 1. 데이터베이스 분리 방식 (Database-per-Tenant)

### 장점 (Pros):
- ✅ **완전한 데이터 격리**: 한 식당의 데이터가 다른 식당에 절대 노출되지 않음
- ✅ **최적의 성능**: 각 식당의 워크로드가 독립적
- ✅ **무한 확장성**: 새로운 식당 추가 시 새로운 DB만 생성하면 됨
- ✅ **독립적 백업/복원**: 식당별 개별 백업 가능
- ✅ **커스터마이징 용이**: 식당별로 다른 스키마 적용 가능
- ✅ **보안 강화**: 한 식당 해킹되어도 다른 식당 영향 없음

### 단점 (Cons):
- ❌ **관리 복잡성**: 여러 데이터베이스 관리 필요
- ❌ **비용 증가**: DB 인스턴스당 비용 발생
- ❌ **모니터링 복잡**: 여러 DB 상태 모니터링 필요
- ❌ **업데이트 복잡**: 모든 DB에 동일 업데이트 적용 필요
- ❌ **개발 복잡성**: 멀티 DB 연결 로직 필요
- ❌ **리소스 낭비**: 소규모 식당에도 전체 DB 리소스 할당

### 구현 예시:
```typescript
// 각 식당별 DB 연결
const getRestaurantDb = (restaurantId: string) => {
  const connections = {
    'restaurant_1': process.env.DB_RESTAURANT_1,
    'restaurant_2': process.env.DB_RESTAURANT_2,
    // ...
  }
  return createConnection(connections[restaurantId])
}
```

---

## 🏗️ 2. 데이터베이스 통합 방식 (Shared Database)

### 장점 (Pros):
- ✅ **관리 용이성**: 단일 데이터베이스만 관리
- ✅ **비용 효율성**: 하나의 DB로 모든 식당 처리
- ✅ **업데이트 단순**: 한 번의 변경으로 모든 식당 적용
- ✅ **개발 단순성**: 단일 연결 로직
- ✅ **공유 리소스 활용**: 대용량 데이터 효율적 처리
- ✅ **모니터링 단순**: 하나의 DB만 모니터링

### 단점 (Cons):
- ❌ **데이터 격리 취약**: RLS 정책 실패 시 데이터 유출 가능성
- ❌ **성능 저하 가능**: 대용량 데이터 시 쿼리 성능 저하
- ❌ **확장성 제한**: 단일 DB의 물리적 한계
- ❌ **커스터마이징 어려움**: 모든 식당이 동일 스키마 사용
- ❌ **백업 복잡성**: 모든 식당 데이터가 하나의 백업 파일
- ❌ **Hotspot 발생**: 특정 식당의 과도한 사용으로 전체 성능 영향

### 구현 예시:
```typescript
// 모든 쿼리에 restaurant_id 필터링
const getMenuItems = async (restaurantId: string) => {
  return await supabase
    .from('menu_item')
    .select('*')
    .eq('restaurant_id', restaurantId)
    .eq('is_active', true)
}
```

---

## 🎯 3. 하이브리드 방식 (Hybrid Approach)

### 개념:
- **핵심 데이터**: 통합 데이터베이스 (사용자, 설정 등)
- **트랜잭션 데이터**: 식당별 분리 데이터베이스 (주문, 대기 등)

### 장점:
- ✅ **균형 잡힌 접근**: 보안과 성능의 균형
- ✅ **최적화된 비용**: 중요한 데이터만 분리
- ✅ **유연한 확장**: 필요에 따라 분리/통합 조정 가능

### 단점:
- ❌ **아키텍처 복잡성**: 두 가지 방식 관리 필요
- ❌ **개발 복잡도 증가**: 이중 연결 로직 필요

---

## 📈 4. 선택 기준

### 데이터베이스 분리 방식이 좋은 경우:
- 🔹 **보안이 최우선**: 금융, 의료 데이터처럼 보안이 critical
- 🔹 **규모가 큰 식당**: 대용량 데이터 처리 필요
- 🔹 **커스터마이징 요구**: 식당별로 다른 기능 요구
- 🔹 **독립적 운영**: 각 식당이 완전히 독립적 운영 희망
- 🔹 **고비용 허용**: 인프라 비용 증가 감수 가능

### 데이터베이스 통합 방식이 좋은 경우:
- 🔹 **비용 최적화**: 예산이 제한적
- 🔹 **관리 효율성**: IT 인력이 제한적
- 🔹 **표준화 요구**: 모든 식당이 동일 기능 사용
- 🔹 **빠른 출시**: 개발 기간 단축 희망
- 🔹 **소규모/중규모**: 데이터 규모가 크지 않음

---

## 💰 5. 비용 비교

### 데이터베이스 분리 방식:
```
10개 식당 기준:
- Supabase Pro: $25 × 10 = $250/월
- 총합: $250/월 + 관리 비용
```

### 데이터베이스 통합 방식:
```
10개 식당 기준:
- Supabase Pro: $25/월 (단일)
- 총합: $25/월 + 개발 비용
```

### 결론: **통합 방식이 90% 비용 절감**

---

## ⚡ 6. 성능 비교

### 데이터베이스 분리 방식:
- ✅ **쿼리 성능**: 각 DB가 독립적이므로 최적
- ✅ **동시성**: 식당별 워크로드 분산
- ✅ **캐싱**: 식당별 캐시 전략 가능

### 데이터베이스 통합 방식:
- ⚠️ **쿼리 성능**: restaurant_id 필터링으로 인한 오버헤드
- ⚠️ **동시성**: 모든 식당이 하나의 DB 공유
- ⚠️ **인덱스 전략**: 복합 인덱스 필요

### 최적화 방안 (통합 방식):
```sql
-- 복합 인덱스 생성
CREATE INDEX idx_menu_item_restaurant_active
ON public.menu_item(restaurant_id, is_active, sort_order);

-- 파티셔닝 고려 (대용량 시)
-- RLS 정책 최적화
```

---

## 🔒 7. 보안 비교

### 데이터베이스 분리 방식:
- ✅ **Zero-trust**: 물리적 데이터 격리
- ✅ **침투 최소화**: 한 식당 해킹해도 타격 최소
- ✅ **접근 제어**: DB 레벨에서 완전 격리

### 데이터베이스 통합 방식:
- ⚠️ **정책 의존**: RLS 정책에 보안이 달려있음
- ⚠️ **침투 위험**: 한 계정으로 모든 데이터 접근 가능
- ⚠️ **정책 실패**: RLS 정책 실패 시 대규모 데이터 유출

### 보안 강화 방안 (통합 방식):
```sql
-- 엄격한 RLS 정책
CREATE POLICY "strict_restaurant_isolation" ON public.menu_item
  FOR ALL
  USING (
    restaurant_id::text = current_setting('app.current_restaurant_id')
  );

-- 감사 로그
CREATE TABLE audit_log (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id uuid REFERENCES restaurant_settings(restaurant_id),
  user_id uuid,
  action text,
  table_name text,
  record_id uuid,
  created_at timestamptz DEFAULT now()
);
```

---

## 🚀 8. 확장성 비교

### 데이터베이스 분리 방식:
- ✅ **수평 확장**: 새로운 DB 인스턴스 추가로 무한 확장
- ✅ **지역별 배포**: 식당 위치에 맞는 DB 서버 배치 가능
- ✅ **워크로드 분산**: 대형 식당에 더 큰 DB 할당 가능

### 데이터베이스 통합 방식:
- ⚠️ **수직 확장**: 단일 DB의 물리적 한계
- ⚠️ **지역 제한**: 모든 데이터가 하나의 지역에 집중
- ⚠️ **리소스 공유**: 대형 식당이 소형 식당 리소스 잠식 가능

---

## 📊 9. 운영 복잡성 비교

### 데이터베이스 분리 방식:
- ❌ **모니터링**: 10개 식당 = 10개 DB 모니터링
- ❌ **백업**: 개별 백업 전략 및 스케줄링
- ❌ **업데이트**: 모든 DB에 동일 패치 적용
- ❌ **문제 해결**: DB별로 다른 문제 발생 가능

### 데이터베이스 통합 방식:
- ✅ **모니터링**: 단일 DB 모니터링
- ✅ **백업**: 하나의 백업 전략
- ✅ **업데이트**: 한 번의 변경으로 전체 적용
- ✅ **문제 해결**: 통합된 문제 해결 프로세스

---

## 🎯 10. 추천 아키텍처

### 소규모/중규모 (1-50개 식당):
**통합 데이터베이스 방식 추천**
- 비용 효율성 높음
- 관리 용이성
- 빠른 개발 속도

### 대규모/엔터프라이즈 (50개 이상 식당):
**하이브리드 방식 추천**
- 보안과 성능 균형
- 단계적 마이그레이션 가능
- 비용과 복잡성 균형

### 초대규모/특정 보안 요구:
**분리 데이터베이스 방식 추천**
- 최고 수준의 보안과 성능
- 무한 확장성
- 독립적 운영 가능

---

## 💡 11. 마이그레이션 전략

### 통합 → 분리로의 마이그레이션:
1. 새로운 DB 인스턴스 생성
2. 데이터 마이그레이션 스크립트 작성
3. 점진적 데이터 이전
4. 라우팅 로직 업데이트
5. 구 DB 폐기

### 분리 → 통합으로의 마이그레이션:
1. 통합 DB 스키마 생성
2. 데이터 통합 스크립트 작성
3. restaurant_id 컬럼 추가
4. RLS 정책 적용
5. 애플리케이션 업데이트

---

## 🎯 결론

### **대부분의 경우: 통합 데이터베이스 방식 추천**
- **비용 효율성**: 90% 이상 비용 절감
- **관리 용이성**: 단일 시스템 관리
- **개발 속도**: 빠른 기능 개발 및 배포
- **확장성**: 50개까지는 충분한 성능

### **특별한 경우에만 분리 방식 고려**
- 보안이 최우선 (금융/의료급)
- 각 식당이 완전히 독립적 운영
- 대용량 데이터 처리 필요
- 고비용 허용 가능

**현재 상황에서는 통합 데이터베이스 방식으로 시작하는 것을 강력 추천합니다!** 🎉